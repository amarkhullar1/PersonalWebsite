<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Implementing a Leaky Bucket for FHIR â€” Amar Khullar</title>
  <meta name="description" content="How we rateâ€‘limited calls to the PDS FHIR API using a leaky bucket to keep ingestion steady without breaching upstream limits.">
  <link rel="icon" href="/assets/images/favicon.svg" type="image/svg+xml">
  <link rel="stylesheet" href="/assets/css/styles.css">
  <script defer src="/assets/js/script.js"></script>
</head>
<body>
  <header class="site-header">
    <a class="logo" href="/"><span class="accent">A</span>mar Khullar</a>
    <nav class="nav">
      <a href="/index.html#about">About</a>
      <a href="/projects.html">Projects</a>
      <a class="active" href="/blog/index.html">Blog</a>
      <a href="/contact.html">Contact</a>
    </nav>
    <button class="theme-toggle" aria-label="Toggle dark mode" title="Toggle theme">
      <span class="sun">â˜€ï¸</span>
      <span class="moon">ğŸŒ™</span>
    </button>
  </header>

  <main class="section">
    <article class="post">
      <h1>Implementing a Leaky Bucket for FHIR</h1>
      <p class="post-meta"><time datetime="2025-09-10">September 10, 2025</time> Â· 5 min read</p>
      <p>For the NHS Relationship Network, we ingest relationships from GRO registrations and enrich via the PDS FHIR API. To protect upstream services and keep our ingestion steady, we implemented a <em>leaky bucket</em> rate limiter.</p>

      <h2>Constraints</h2>
      <p>FHIR endpoints have documented (and sometimes undocumented) limits. We wanted backâ€‘pressure that smoothed bursts, avoided hot partitions, and made throughput predictable.</p>

      <h2>Design</h2>
      <ul>
        <li>Tokens drip into the bucket at a fixed rate.</li>
        <li>Each outbound FHIR call consumes a token; if empty, we wait.</li>
        <li>We preserved fairness across partitions by sharding queues.</li>
      </ul>

      <h2>Implementation</h2>
      <p><em>Stack:</em> AWS SQS for work queues, Step Functions to orchestrate, Lambda for workers. The bucket is represented by a DynamoDB item with conditional updates (atomic counters) and timeâ€‘based refill logic. CloudWatch metrics tell us when to adjust rates.</p>

      <h2>Results</h2>
      <p>We avoided throttling while keeping a steady ingestion rate. Consumers saw consistent latency, and the system recovered gracefully after upstream slowdowns.</p>
    </article>
  </main>

  <footer class="site-footer">
    <p>Â© <span id="year"></span> Amar Khullar. All rights reserved.</p>
  </footer>
</body>
</html>
